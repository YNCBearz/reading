# SQL與迴歸集合

## 馮紐曼的前輩們

> 表 21.1 馮紐曼對自然數的迴歸性定義

| 自然數 | 重視自然數順序的情況 | 試著還原為集合的情況 |
| :-----: | :----: | :----: |
| 0 | 0 | 0 |
| 1 | {0} | {0} |
| 2 | {0, 1} | {0, {0}} |
| 3 | {0, 1, 2} | {0, {0}, {0, {0}}} |

> 表 21.2 各種自然數迴歸性定義

| 自然數 | 馮紐曼型 | 策梅洛 | 弗雷格 |
| :-----: | :----: | :----: | :---: |
| 0 | 0 | 0 | {0} |
| 1 | {0} | {0} | {0, {0}} |
| 2 | {0, {0}} | {{0}} | {0, {0}, {0, {0}}} |
| 3 | {0, {0}, {0, {0}}} | {{{0}}} | {0, {0}, {0, {0}}, {0, {0}, {0, {0}}}} |

---

首先，策梅洛的規則非常簡單。
**幾個左括號（或右括號），會與要定義的數一致。**

而在馮紐曼的方式裡，**集合元素數量與要定義的數一致。**

由於SQL能以COUNT函數計算元素個數，所以與馮紐曼的定義相容。
（不過也是因為SQL本來就不使用括號標記集合）。

弗雷格的定義與馮紐曼相當類似，但0不是從空集合開始。

---

但這個定義，還有兩個問題沒有解決。

1. 自然數的定義有必要這麼多嗎？定義通常只需要一個。
2. 為什麼要利用「集合」定義自然數呢？

## 數為何物？

> 任意自然數a必有其後繼元素 (successor) 存在

---

**皮亞諾公理**

---

```
0 = 0
1 = suc(0)
2 = suc(1) = suc(suc(0))
3 = suc(2) = suc(suc(1)) = suc(suc(suc(0)))
```

**馮紐曼與弗雷格的後繼函數：suc(a) = a ∪ {a}**

**策梅格的後繼函數：suc(a) = {a}**

---

這下子可以回答剛剛的問題了。

> 自然數的定義有必要這麼多嗎？定義通常只需要一個。

馮紐曼等人想出了對應皮亞諾定義的構成方法。
連具體構成方法（後繼函數）都納入定義，這定義才有意義。

> 為什麼要利用「集合」定義自然數呢？

要組成自然數**不一定要用集合**。

---

Lambda λ運算式：以函數為參數，同時輸出函數的高階函數。

```
0 : λf x. x
1 : λf x. f x
2 : λf x. f (f x)
3 : λf x. f (f (f x))
```
