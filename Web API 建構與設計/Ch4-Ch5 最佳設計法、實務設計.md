# **Ch4 最佳設計法**
### **設計實際使用案例**
- 想像使用API的開發者會用你的API完成哪些工作 ?
- 開發者能夠建立哪些的app類型 ?

對於某些公司而言，這些問題的答案等於「開發者必須讓顧客掏出信用卡買單」; 而對於其他答案比較開放的公司則是「必須能夠讓開發者建立一套有互動性、高品質的app」。

### 很多API是根據app內部結構來設計的，這會洩漏實作的細節，造成第三方開發者的混淆，以及糟糕的開發體驗。

> API必須讓開發者把一件事做得很好，這件事不像聽起來那麼容易，而且你也要說明API不負責哪些事情。

### **設計絕佳的開發者體驗**
- 易用性：讓API快速、容易上手
- 一致性：反映在端點名稱、輸入參數與輸出回應上
- 易除錯：讓問題更容易被排除
- 可擴展：確保頂級夥伴有提供回饋的機會

> 設計API很像設計一個運輸網路，好的API不會限定最終的狀態或目標，而是擴展開發人員的可能性。

### **易用性**
除了列出API規格文件外，加入**個別指導**或**入門指南**也很有幫助。
- 個別指導是教導開發者使用API的互動式頁面，或許可讓開發者在一個輸入區域填入程式碼。
- 入門指南則是比規格更為白話的文件，它提供開發者在某個時間點需要的資訊。

> 你可以提供線上互動式文件來提供易用性，並在那裡提供沙盒來讓開發者測試API。開發者可在不註冊的情況下，來測試程式並預覽結果。

### **一致性**
**讓開發者在不閱讀文件的情況下猜到部分的API。**

包括資料存取模式、錯誤處理與命名等。
> 一致性通常代表整個API有許多重複的模式與規範。它可以減少試著瞭解你的API的開發者的認知負擔(cognitive load)

### **易除錯**
**藉由回傳有意義的錯誤以及建構工具來做到這一點。**

#### **有意義的錯誤**

錯誤可能發生在程式的許多路徑上，包括API的請求過程中的授權錯誤、特定實例不存在的商業邏輯錯誤，以及低階的資料庫連接錯誤。提供錯誤的細節可帶來較佳的使用者體驗。

**表4-1 各種錯誤下的錯誤碼範例**
| 情況 | 建議 | 不建議 |
| :---- | :---- | :---- |
| 權杖被撤銷，而造成驗證失敗 | **token_revoked** | **invalid_auth** |
| 名稱值超出最大長度 | **name_too_long** | **invalid_name** |
| 信用卡過期 | **expired_card** | **cannot_refund** |
| 因為費用已被退還而無法退款 | **charge_already_refunded** | **cannot_refund** |

**表4-2 將錯誤分成高階的類別**

| 錯誤類別 | 範例 |
| :---- | :---- |
| 系統級錯誤 | 資料庫連接問題 |
|  | 後端服務連接問題 |
|  | 嚴重錯誤 |
| 商業邏輯錯誤 | 速率限制 |
|  | 請求被滿足了，但找不到結果 |
|  | 因為商務原因而拒絕讀取資訊 |
| API 請求格式錯誤 | 缺少必要的請求參數 |
|  | 組合的請求參數是無效的 |
| 授權錯誤 | 請求的OAuth憑證無效 |
|  | 權杖過期 |

**表4-3 將你的錯誤組織為狀態碼、標頭、機器可讀的代碼與人類可讀的字串**

| 錯誤種類 | HTTP狀態 | HTTP標頭 | 錯誤碼（機器可讀的) | 錯誤訊息（人類可讀的） |
| :---- | :---- | :---- | :---- | :---- |
| 系統級錯誤 | 500 | -- | -- | -- |
| 商業邏輯錯誤 | 429 | **Retry-After** | **rate_limit_exceeded** | 你已經被限速了，查看Retry-After再重試一次 |
| API請求格式錯誤 | 400 | -- | **missing_required_parameter** | 你的請求缺少{user}參數 |
| 身分驗證錯誤 | 401 | -- | **invalid_request** | 你的ClientId不正確 |

#### **建構工具**

除了讓開發者更容易排除問題外，你也要建構內部與外部的工具來讓你自己更輕鬆。

當你解決開發者問題時，可以 *log* (記錄) HTTP狀態、錯誤、錯誤的頻率以及其他的請求詮釋資料，以便在內部與外部使用。

### **可擴展**

可以提供一種應付破壞性變動(**breaking change**)的機制。

- 採納早期的回饋：**beta**版本
- 管理API的版本：隨著時間推移，版本管理系統會越來越難實施
- 維持回溯相容性

# **Ch5 實務設計**

## **情況1**
### **定義商務目標**
- 你想要解決什麼問題？
- 你想要透過 API 造成什麼影響？

### **列舉關鍵使用者故事**
As a **[user type]**, I want **[action]** so that **[outcome]**.

(身為 **[使用者類型]** ， 我想要 **[做什麼事]** 來實現 **[結果]** 。)

- 身為**開發者**，我想要**請求一系列的檔案**來**查看使用者上傳了哪些東西**。

- 身為**開發者**，我想要**請求單一檔案的細節**以便**取得使用者上傳的檔案中的細節**。

- 身為**開發者**，我想要**以使用者的名義上傳/編輯檔案**，如此一來，**使用者就不需要為了將檔案加至 MyFiles 而離開我的 app 了**。

### **選擇技術結構**

**表5-1 MyFiles API 的各種API模式的優缺點**

| 模式 | 優點 | 缺點 | 選擇? |
| :---- | :---- | :---- | :---- | :---- |
| REST | MyFiles 本質上是資源導向的。這些資源是已歸檔的內容與詮釋資料。我們要支援的操作是簡單的建立 (Create) 、 讀取 (Read) 、 更新 (Update) 與刪除 (Delete) (統稱CRUD)操作| REST 可以長期當成檔案的資源模型來使用。如果我們需要支援好幾種操作，或許就不適合使用 REST。 | ✔️ |
| RFC | 除了 CRUD 之外也可以增加其他的操作。 | 此時這個 API 不會執行 CRUD 之外的操作，因此應該不需要支援其他的操作 | ❌ |
| GraphQL | 對開發者來說很靈活。容易維持小型的負載 | 實作起來過於複雜。此時還不需要讓用戶端表達 | ❌ |

### **編寫 API 的規格**
**建議使用具備版本控制與註解支援的合作文件編輯軟體**

(參見書中 p70.**表5-4**、 p71.**表5-5**)
- 輸入欄位須寫**型別**及**限制 (預設值、上下限)**
- 輸出欄位須寫**成功回應**與**型態**
- 若有使用OAuth，須寫出授權 API 方法的存取範圍
- 錯誤欄位會列出**使用者錯誤**
- 不要在這裡列出**一般錯誤**及**系統錯誤**

## **情況2**

### **列舉關鍵使用者故事**
- 身為一位**開發者**，我想要**在有檔案被加入、更改或移除時收到更新**，如此一來，**我就不需要持續輪詢 Rest API 了**。

### **選擇技術結構**

**表5-6 MyFiles API 的事件驅動API的優缺點**

| 模式 | 優點 | 缺點 | 選擇? |
| :---- | :---- | :---- | :---- | :---- |
| WebHook | MyFiles 開發者可能希望每次有檔案被加入、移除或改變時收到事件。 | 如果檔案經常被更改，我們可能需要複雜的基礎結構來消除重複的事件，以免無意間啟動開發者的 app 上面的分散式阻斷服務攻擊 (DDos) 事件。 | ✔️ |
| WebSocket | 可讓內部用戶端用來顯示 UI 。 | 我們不希望讓開發者透過 API 為 MyFiles 建立 UI用戶端。| ❌ |
| | | 我們認為，開發者想要瞭解的事件類型不需要用到長期連結。 | |
| HTTP Streaming | 適合頻繁地推送資料 | 由於檔案的更改頻率很低，我們認為不需要使用 HTTP Streaming。 | ❌ |

### **編寫 API 的規格**
除了高階的概述之外，我們也要編寫關於事件以其負載的細節。

(參見書中 p76.**表5-7**)

### **驗證你的決策**
> 在早期取得正確的回饋可以節省許多時間，避免付出高額的代價重寫程式。

#### 與關係人一起審查規格
收集回饋的目的不是簡單地 “簽字同意” ，應該歡迎對方提出建設性的反面意見與批評。

### **模擬資料來做互動式使用者測試**
模擬資料 app 是比較有互動性的測試環境，可幫助你在完整實作 API 之前取得更具體的回饋。

### **Beta 測試者**
用 beta 測試程式讓開發者夥伴搶先體驗新的 API，讓你有額外的機會為真正的使用者與使用案例改善 API 的設計。

### **總結**
可考慮盡量讓開發程序維持**輕量**與快速，同時取得最多的**回饋**。

> 不良的設計決策是 API 提供者忽略使用者或開發者社群需求造成的。



