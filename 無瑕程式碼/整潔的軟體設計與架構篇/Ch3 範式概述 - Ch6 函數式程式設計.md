# **範式概述 (PARADIGM OVERVIEW)**

### 以下會討論三種範式：
 1. 結構化程式設計 (**structured programming**)
 2. 物件導向程式設計 (**object-orient programming**)
 3. 函數式程式設計 (**functional programming**)

---

## 結構化程式設計 (**structured programming**)

> ### **GoTo 有害論**
Edsger Wybe Dijkstra 是名以「理論物理學家」為頭銜的程式設計師。他很早認識到程式設計是困難的，於是期望以**數學原理**證明的方式，來證明程式是正確的。

在展開研究中，Dijkstra發現 **goto** 語句的某些使用方式，會阻止模組遞迴地被分解成越來越小的單元，進而導致無法使用**分治法 (divide-and-conquer)** 來進行證明。

然而 **goto** 的其他使用方式沒有這個問題。於是
Dijkstra 將其對應成簡單的 **選擇 (selection)** 和 **迭代 (iteration)** 控制結構。

例如 **if/then/else 和 do/while**。模組若只使用這些類型的控制結構，就**可以**被遞迴地細分為可證明的單元。

這場 **GoTo有害論** 的爭論持續了10年，最終以Dijkstra的勝利作為結束。

> ### **曾有正式的證明**
但從來沒有完成過。原因是科學定理和定律的本質：他們是**可證偽 (*falsifiable*)** ， 但不是可證明的。

> ### **測試**
Dijkstra 曾經說過：「測試顯示了錯誤的存在，而不是沒有錯誤」

---

## 物件導向程式設計 (**object-orient programming**)

> ### 封裝?
C 擁有在非 OO 語言的完美封裝（可以在不知道資料結構的實作或函式的實作下，呼叫函式）。

但隨著 C++ 型式的 OO 出現後，C 的完美封裝就被破壞了。

後來的 JAVA 和 C# 也只是簡單地廢除了標頭/實作的分拆，因此更弱化了封裝。這些語言中無法將一個類別的**宣告 (declaration)** 和 **定義 (definition)**分離。

基於這些原因，我們很難接受 OO 是依賴在強封裝之上。

OO 的確依賴於一個前提，就是程式設計師必須具備「不會設法迴避資料封裝」的相關良好行為。

> ### 繼承?
在 OO 出現以前就有繼承這樣的手法，但並不如繼承這樣方便。

> ### 多型?
在 OO 出現以前，設計師用「指向函式的指標」來實現多型。
但 OO 語言使得多型更安全與更方便。

> ### 總結
事實上， OO 語言提供的安全且方便的多型意味著，**無論在何處，任何的原始碼依賴都可以被反向。** 這就是所謂的**依賴反向 (*dependency inversion*)** 。

對於軟體架構師來說， OO 透過使用多型，來獲得對於系統中每個原始碼依賴方向的絕對控制力。

---

## 函數式程式設計 (**functional programming**)

> ### 整數的平方
相對於 Java 用一個 **可變的變數 (mutable variable)** 去計算前25個整數的平方， Clojure則使用像x的變數去初始化，而它們永遠不會被改變。

函數式語言中的變數**不會改變 (do not vary)**。

> ### 不可變與架構

為什麼架構師會關心變數的可變性？

因為所有的 **競爭條件 (race condition)**、 **deadlock條件 （死結條件）** 和 **平行更新問題 (concurrent update problem)** 都來自於可變的變數。

> ### 可變性的分離
在不變性方面最常見的折衷手段是，將服務分為可變和不可變的元件。不可變的元件以純函數式的方式執行他們的任務，不使用任何可變的變數。

> ### 事件來源 (event sourcing)
事件來源是種策略，在此策略中，我們儲存的是交易而非狀態。當需要取得狀態時，我們只是簡單地從源頭開始應用所有的交易。

若我們有足夠的儲存空間和足夠的處理器能力，我們就可以寫出完全**函數式化 (entirely functional)** 的程式。
（也就是說我們的應用程式不是 CRUD ，而是 CR ）

這是否聽起來很荒唐，但這就是你的原始碼控制系統的工作方式。

---

## 總結

1. 結構化程式設計 (**structured programming**) 就是在**直接控制移轉**上加上規範。
2. 物件導向程式設計 (**object-orient programming**)就是在**間接控制移轉**上加上規範。
3. 函數式程式設計 (**functional programming**) 就是在**變數賦值**上加上規範。

我們在過去半個世紀裡所學到的，是**哪些是不該做的 (what not to do)** 。