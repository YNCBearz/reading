# **Chapter6 狀態**

### 物件在包裝**行為** (*behavior*)和 **狀態** (*state*)時提供了便利性：
- 行為被暴露給外部世界，而狀態則為行為提供了支援
- 利用物件將狀態分割成小塊，就比較容易分析出每次修改會影響的範圍

----------------------------------------------------------------

## **狀態 (State)** - 利用可變的值進行計算

- 函數式程式語言 (Funtional programming languages) 不允許改變狀態

- 物件程式語言 (Object languages)採用了處理狀態的策略，將系統細分至各個小塊，因而有機會避免「狀態在背後偷偷改變」的問題

> **有效管理狀態的關鍵在於：把相似的狀態放一起，確保不同狀態彼此分離**

### 兩條線索可指出兩個狀態的相似性：
  1. 它們在同一個計算中被用到
  2. 出現和消滅的時間相同，換言之，有相同的生命週期

----------------------------------------------------------------

## **存取 (Access)** - 限制對狀態的存取，進而保持靈活性

> **物件的功能之一是管理儲存空間。**
### 每個物件看起來都是獨立的計算環境，在某種程度上與其他計算環境隔離

----------------------------------------------------------------

## **直接存取 (Direct Access)** - 直接存取物件內部的狀態

> **優點: 表述清晰**
>
> **缺點: 失去靈活性且操作屬於實作細節**

----------------------------------------------------------------

## **間接存取 (Indirect Access)** - 透過方法來存取狀態，進而提高靈活性

### 可以用「方法呼叫」來隱藏對狀態的存取和修改

> 作者預設策略是允許在類別(以其內部類別)中直接存取，其他使用者則必須間接存取

### 不建議完全禁止直接存取，會使人不假思索地直接實作該功能，而不是思考「該把計算邏輯放在什麼地方」

> 當兩項資料彼此耦合時，無疑地，應該使用間接存取

----------------------------------------------------------------

## **通用狀態 (Common State)** - 把狀態保留在欄位 (field) 中，使得該類別的所有物件都擁有這些狀態

### 很多計算邏輯會用到同樣的資料項目，為了表達意圖，應該把它們之間共同的資料項目宣告為『一個類別中的欄位』

> 通用狀態的好處是能清晰表達『需要哪些資料才能呼叫一個物件的功能』，物件中所有的通用狀態應該有相同的作用域 (scope) 和生命週期 (lifetime) 。

----------------------------------------------------------------

## **可變狀態 (Variable State)** - 如果各個實體擁有不同狀態，將這些狀態放入map，並將map保存在執行個體變數中

有時候依據不同的使用方式，同一個物件需要不同的資料元素

可變狀態通常用map來保存，其中的鍵 (key) 是資料元素的名字，值 (value) 則是資料值

可變狀態比通用狀態要靈活得多，但表意並不清晰 (需要哪些資料項目才能讓它正常工作?)

> 如果遇到一個欄位決定了同一個物件是否需要其他欄位，這種情況就應當使用「可變狀態」

通用狀態也能表述該種狀況，但違反了「物件中執行個體變數生命週期相同」

借助多型可以更清晰地表達這種情況

如果**變數有相同的字首**，那可能意味著應該引入某種**輔助物件 (helper object)**

> 要儘量使用「通用狀態」，只有當『是否某些欄位，必須視使用方式而定』時，才考慮使用「可變狀態」

----------------------------------------------------------------

## **外生狀態 (Extrinsic State)** - 某些特殊用途的狀態可以放入一個map，並由狀態的使用者負責保存

有時程式中的某一部分需要『與某個物件有關的狀態』，但系統的其他部分並不需要這個狀態。

把這些資訊放在物件欄位會違反**對稱性原則**，特殊用途的資訊應該放在使用該資訊的地方

> 外生狀態的缺點：「物件複製」變得困難、「難以除錯」

----------------------------------------------------------------

## **變數 (Variable)** - 變數提供了存取狀態的命名空間

變數依其作用域，可分為：
- 區域變數，只能在當前作用域中使用
- 欄位，可以在物件內任何地方存取
- 靜態變數，該類別的所有物件都可以存取

作用域又可以用修飾符加以限制，可選用的修飾符有public、package、protected 和 private

### 為了減少耦合，大多數時候都應該使用區域變數和private欄位 (偶爾使用靜態欄位)
### 若只使用受限制的少數組合，閱讀者就能只憑上下文來釐清自己看到的是區域變數還是欄位
> 若在當前作用域能看到變數宣告，則為區域變數；反之，就是欄位

變數生命週期可能比作用域要小，但應該儘量保持兩者一致，

此外也應該盡量保持兄弟變數 (同一個作用域中定義的變數) 擁有相同的生命週期

> 如果作用域、生命週期和型別都能用別的方式充分描述，
> 那名稱本身就可以只用於『描述變數在計算邏輯中扮演的角色』

----------------------------------------------------------------

## **區域變數 (Local Variable)** - 變數可在單一作用域內保存狀態

遵照「資訊最小擴散」原則，應該在『盡可能靠內的作用域』以及『在確實需要時』才宣告區域變數

### 區域變數常扮演的角色有以下幾種：
- **集合器 (Collector)** : 用變數來收集稍後需要的資訊，若需要將集合器返回，就將它命名為result或results
- **記數 (Count)** : 特殊的集合器，用來記錄某些物件的個數
- **解釋 (Explaining)** : 若有一個複雜的運算式，可以把運算式部分結果指派給一個區域變數，進而幫助閱讀者理解整個複雜的運算

> 解釋型區域變數，可以進一步變成輔助方法 (helper method)

- **重複使用 (Reuse)** : 若一個運算式的值會不斷變化，而你又需要使用同一個值不只一次時，就應該將其保存在區域變數中
- **元素 (Element)** : 在遍歷 (iterate) 集合時指定為其中的元素，稱之為元素區域變數 (element local variable)

----------------------------------------------------------------

## **欄位 (Field)** - 欄位保存的狀態在物件的整個生命週期皆有效

可以宣告在整個物件的最前面或最後面
- 宣告在最前面 : 閱讀者在看到其他程式碼之前，就能對上下文有大致的瞭解
- 宣告在最後面 : 表達「行為」是王，「資料」只是實作細節

還可以把欄位宣告為 final，以此告訴閱讀者：建構函式執行後，就不能再改變欄位的值

### 欄位常扮演的角色有以下幾種：
- **助手 (Helper)** : 用於存放其他物件的參考，若有一個物件以參數的方式傳給很多個方法，就可以考慮改為透過助手欄位 (而不是參數) 獲得所需的物件，並在建構函式中完成助手欄位的設定
- **旗標 (Flag)** : 如果根據某個旗標作出判斷的邏輯出現了重複，則應該考慮改為使用「策略」欄位
- **策略 (Strategy)** : 如果想要表達「這部分計算有幾種不同的方式來進行」，就應該把一個『只執行這部分可變的計算』的物件保存在一個欄位中
- **狀態 (State)** : 狀態欄位與策略欄位有相似之處，亦即它們所在的物件皆會把一部分行為委派給它們。但狀態欄位在被觸發時會自己設置相關的狀態，而策略欄位的改變是由其他物件來進行
> 用狀態欄位實作的狀態機 (State Machine)會很難理解，因為狀態和變遷 (transitions) 並不在同一個地方描述
- **元件 (Component)** : 用來保存由所在物件「擁有」的物件或資料

----------------------------------------------------------------

## **參數 (Parameter)** - 參數在一個方法被呼叫之初，可用來描述當時的狀態

由於非私有變數會在類別間造成強耦合，所以只要有可能，就應該儘量使用參數傳遞狀態

比起從一個物件永久地參考另一個物件，參數帶來的耦合要弱得多

> 如果一個物件給另一個物件發送的許多訊息都需要同一個參數，
> 那麼也許更好的解決辦法是把這個參數永久地交給被呼叫的物件

----------------------------------------------------------------

## **收集參數 (Collecting Parameter)** - 傳入一個參數，用來收集來自多個方法的複雜結果

有時計算邏輯需要從多次的方法呼叫中收集結果，並將這些結果以某種方式合併起來

我們可以讓每個方法都回傳一個值，如果回傳值很簡單，那麼這種辦法就是可行的

> 但如果「合併結果」不只是「把結果相加」那麼簡單，
> 傳入一個參數來收集結果就顯得較為直覺了


----------------------------------------------------------------

## **可選參數 (Optional Parameter)**

有些方法既可以接受某個參數，也可以在使用者不提供參數時提供預設值

> 在這種情況下，必要的參數應該放在參數清單的前面，隨後加上可選的參數

----------------------------------------------------------------

## **變長引數 (Var Args)**

有些方法可以接受任意個指定型別的參數

> 「變長引數」必須對應到參數清單的最後，順序為：必要參數 > 可選參數 > 變長引數

----------------------------------------------------------------

## **參數物件 (Parameter Object)** - 把常用的長參數清單打包成一個物件

如果同一組參數被放在一起傳遞給了很多個方法，那麼應該考慮建立一個物件，
把這些參數放入該物件的欄位

用參數物件取代參數清單，接著找出「只使用參數物件中欄位」的程式碼，
把這些程式碼變成參數物件中的方法

> 引入參數物件使程式碼變得更短、意圖更清晰

### 儘管引入參數物件的主要目的是『提高可讀性』，但參數物件也可以成為邏輯的重要去處
### 用一個類別把多個欄位包裝起來，正是明確地說出「這一組資料是高度相關的」

----------------------------------------------------------------

## **常數 (Constant)** - 不變的狀態應該保留為常數

有些程式中有幾個地方需要相同的資料，但這些資料不會改變
這些變數就是常數，常數的名字通常全部大寫，以強調它們不是普通的變數

> 利用常數的名字來表達這個值所代表的意思

----------------------------------------------------------------

## **按角色命名 (Role-Suggesting Name)** - 根據變數在計算中扮演的角色替它們命名

變數名稱應該展現變數中存放的資料會被如何使用，以及這些資料在計算邏輯中扮演什麼樣的角色

- result - 保存將被當前函式返回的物件
- each - 在對集合進行遍歷操作時，保存集合中的各個元素
- count - 保存計數器


----------------------------------------------------------------

## **宣告時的型別 (Declared Type)** - 替變數宣告一個盡可能通用的型別

用宣告時的型別來描述「如何使用這個變數」

> 如果可能的話，把變數和方法的型別宣告得廣泛一些會有好處，但降低一點點廣泛的程度、損失一點點的精確性，也是合理的權衡

----------------------------------------------------------------

## **初始化 (Initialization)** - 盡可能以『宣告的方式』對變數進行初始化

所謂「初始化」，就是『在使用變數之前，把它們設置到某個已知
狀態的過程』

----------------------------------------------------------------

## **盡早初始化 (Eager Initialization)** - 在建立實體的同時，初始化欄位

第一種初始化風格是：一旦變數出現就立即進行初始化 (在宣告陳述式或在建構函式中)

> 盡早初始化的好處在於，可以保證變數在使用之前一定是被初始化過的

----------------------------------------------------------------

## **延遲初始化 (Lazy Initialization)** - 如果欄位的求值動作代價高昂，可以考慮在第一次使用之前才初始化

如果計算的成本很高，而你又希望延遲支付這些成本 (可能因為這些變數或許根本不會被使用到)，那麼就建立一個 getter 方法，在第一次呼叫該方法時初始化欄位

> 延遲初始化給閱讀者傳遞的資訊是：在這裡，效能非常重要

----------------------------------------------------------------
