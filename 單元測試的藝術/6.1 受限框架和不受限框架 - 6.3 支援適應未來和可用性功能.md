# 6.1 受限框架和不受限框架 - 6.3 支援適應未來和可用性功能

## 6.1 受限框架與不受限框架

依據程式語言**實現特定功能的能力**，可將隔離框架分為兩類。

### 6.1.1 受限框架

> .NET 的受限框架有 Rhino Mocks、Moq、NMock、 EasyMock、NSubstitute、和 FakeItEasy 等等。

我們把它們稱為**受限框架**，因為有些東西是這些框架不能偽造的。框架能偽造什麼，不能偽造什麼，通常是依據它們所運行的平台，以及它們如何使用平台所決定。

.NET 受限框架**不能偽造靜態方法、非虛擬方法及非公開方法等。**

受限框架通常透過在執行時期，產生繼承和覆寫介面或基底類別的程式。因此它們受限於編譯器和中間語言 (Intermedia Language, IL) 的能力。

### 6.1.2 不受限框架

> .NET 的不受限框架有 Typemock Isolator、JustMock 和 Moles (a.k.a. MS Fakes) 等等。

以下深入探討.NET不受限框架是如何運作的。

透過 **探查器API (profiling API)** 的非託管 (unmanaged) API，能夠對於 CLR (Common Language Runtime) 執行程式碼時發生的事情，修改和注入新的中間語言程式碼。

因為探查器的事件是針對所有程式碼的，包含靜態方法、私有建構式、甚至包括不屬於你的第三方程式碼。這使得.NET不受限框架能夠注入、修改任何程式碼，即便它們不是你編譯的。

使用不受限框架有以下優點：
- 可以替那些以前無法寫測試的程式來撰寫單元測試，因為你無法修改和重構產品程式碼，就可以替工作單元建立假物件來取代直接相依的物件，並將它們隔離。你可以在擁有測試的情況下重構。

- 你可以替無法控制或很難進行測試的第三方系統進行測試。

- 你可以決定自己設計的彈性與複雜度，而不是被迫使用某些設計模式。

然而，使用不受限框架也有以下缺點：
- 你可能會偽造了不需要的東西，導致失去了在抽象層次較高的角度來了解工作單元。

- 如果不小心，你可能會偽造了不屬於你的 API，可能會導致一些測試無法被維護。但以作者的經驗，情況發生的機會並不頻繁。

### 6.1.3 基於探查器的不受限框架是如何運作的

若你想要撰寫一個.NET不受限框架的競爭產品，這些知識對你會產生額外的幫助。

### 6.1.4 框架揭露了不同的探查器能力

從可能性來說，所有基於探查器的隔離框架，都有同樣的底層功能。但現實中，.NET的主要框架在功能上各有不同。

歷史最為悠久的 **Typemock** 支援所有你在測試遺留程式碼中，沒法測試的東西，包括尚未存在的物件、靜態建構式等。

**Typemock** 只在偽造 **mscorlib.dll** 的 API 方面有所欠缺。包括如 **DateTime**、**System.String** 和 **System.IO** 命名空間的關鍵 API。

技術上， **Typemock** 可允許使用者偽造整個 **mscorlib.dll** ， 但因為效能問題使得這並不可行。

對比 **Typemock Isolator**，**MS Fakes**有一些優勢。由於是微軟內部撰寫，這些開發人員更了解那些沒有在說明文件的探查器 API 。 **MS Fakes** 的 API 主要是允許你用自己的委派來代替公開方法 （靜態或非靜態），但它並不支援對非公開方法的偽實現。

重要的是，要明白在你選擇使用一個隔離框架時，也抉擇了框架所代表的某組基本能力或約束。

---

## 6.2 好的隔離框架的價值

過去.NET領域幾年出現了新的隔離框架，包括了 **Typemock Isolator**、**NSubstitute** 和 **FakeItEasy**。

好的隔離框架具有兩大價值：
- 適應未來
- 可用性

以下是新的測試框架中所支援上述價值的功能：
- 遞迴假物件
- 預設忽略參數
- 大範圍偽造 (Wide faking)
- 假物件的非嚴格行為
- 非嚴格模擬物件

---

## 6.3 支援適應未來和可用性的功能

隔離框架很容易被亂用而產生脆弱和適應未來性較差的測試。

### 6.3.1 遞迴假物件

遞迴假物件是假物件在函數回傳其他物件時的特殊行為。
這些回傳物件會自動產生假物件。而這些假物件所回傳的物件也都是偽造的。

```c#
public interface IPerson
{
    IPerson GetManager();
}

[Test]
public void RecursiveFakes_work()
{
    IPerson p = Substitute.For<IPerson>();
    Assert.IsNotNull(p.GetManager());
    Assert.IsNotNull(p.GetManager().GetManager());
    Assert.IsNotNull(p.GetManager().GetManager().GetManager());
}
```

當你需要告訴測試關於偽造 API 的資訊越少，測試和產品程式碼細部實作的關聯就越少。
將來程式碼異動時，需要對測試的修改就越少。

目前只有.NET框架考慮了這個能力。

### 6.3.2 預設忽略參數

目前在 **Typemock Isolator** 以外的框架中，
送給改變行為的 API 或驗證 API 的任何參數值，都會被當作預設的期望值。

在預設情況下， **Isolator** 忽略傳入的值，除非你在 **API** 呼叫時特別宣告你在乎這個參數值。
這樣就沒有必要在所有方法中，包含 **Arg.IsAny<Type>** ，能少打幾個字，還避免破壞可讀性的泛型。

使用 **Typemock Isolator (typemock.com)**，如果想對任何參數都拋出例外，
可使用下列程式碼：

```c#
Isolate.WhenCalled(() => stubLogger.Write(""))
                         .WillThrow(new Exception("Fake"));
```

### 6.3.3 大範圍偽造

大範圍偽造是一次偽造多個方法的能力。在某種意義上，遞迴假物件是其的子功能。

例如使用 **FakeItEasy** 這樣工具時，你可以指定某個物件的所有方法都回傳同一個值，
或者只對回傳值為特定型別時的方法進行指定：

```c#
A.CallTo(foo).Throws(new Exception());
A.CallTo(foo).WithReturnType<string>().Returns("hello world");
```

使用 **Typemock**，你則可以指定型別中所有靜態方法都預設回傳同一個值：

```c#
Isolate.Fake.StaticMethods(typeof(HttpRuntime));
```

重申一下，大範圍偽造對測試在產品程式碼演化時的未來可維護性具有極大的好處。
例如：六個月之後，一個新的方法被加入到產品程式碼中並被使用，所有已存在的測試仍然能自動偽造這個新方法。

### 6.3.4 假物件的非嚴格行為

一個嚴格假物件的方法，只有透過隔離框架 API 將它設定成預期 (expected) 的，才能成功呼叫它們。
這樣預期一個假物件應該要被呼叫到的特性，在NSubstitute （或 FakeItEasy）中並不存在，
但在.NET或其他語言框架確實存在。（參考 Moq、Rhino Mocks 和 Typemock Isolator 舊版本 API）。

如果一個方法被設定成預期的，那麼任何異於這個預期的呼叫，不管是定義的參數不同，
還是方法名稱不同，通常都會被處理成拋出一個例外。

測試通常對嚴格模擬物件，進行第一次的非預期呼叫時失敗。

一個嚴格模擬物件在兩種情況下可能失敗：
對它呼叫了一個非預期方法，或是沒有對它所設定的預期方法進行呼叫（可透過呼叫 Received() 決定）。

困擾作者的是第一種情況。假如不在乎工作單元內部物件之間的內部協議，那麼就不該對它們之間的互動進行驗證。

### 6.3.5 非嚴格模擬物件

大部分的情況，使用非嚴格模擬物件的測試不會這麼脆弱。
一個非嚴格模擬物件允許對它進行任何方法的呼叫，即使這個呼叫不在原本預期內。

對於有回傳值的方法，如果回傳值的型別為物件，非嚴格模擬物件會回傳預設值。
如果是參考型別，非嚴格模擬物件會回傳 null 。

---

