# 6.1 受限框架和不受限框架 - 6.3 支援適應未來和可用性功能

## 6.1 受限框架與不受限框架

依據程式語言**實現特定功能的能力**，可將隔離框架分為兩類。

### 6.1.1 受限框架

> .NET 的受限框架有 Rhino Mocks、Moq、NMock、 EasyMock、NSubstitute、和 FakeItEasy 等等。

我們把它們稱為**受限框架**，因為有些東西是這些框架不能偽造的。框架能偽造什麼，不能偽造什麼，通常是依據它們所運行的平台，以及它們如何使用平台所決定。

.NET 受限框架**不能偽造靜態方法、非虛擬方法及非公開方法等。**

受限框架通常透過在執行時期，產生繼承和覆寫介面或基底類別的程式。因此它們受限於編譯器和中間語言 (Intermedia Language, IL) 的能力。

### 6.1.2 不受限框架

> .NET 的不受限框架有 Typemock Isolator、JustMock 和 Moles (a.k.a. MS Fakes) 等等。

以下深入探討.NET不受限框架是如何運作的。

透過 **探查器API (profiling API)** 的非託管 (unmanaged) API，能夠對於 CLR (Common Language Runtime) 執行程式碼時發生的事情，修改和注入新的中間語言程式碼。

因為探查器的事件是針對所有程式碼的，包含靜態方法、私有建構式、甚至包括不屬於你的第三方程式碼。這使得.NET不受限框架能夠注入、修改任何程式碼，即便它們不是你編譯的。

使用不受限框架有以下優點：
- 可以替那些以前無法寫測試的程式來撰寫單元測試，因為你無法修改和重構產品程式碼，就可以替工作單元建立假物件來取代直接相依的物件，並將它們隔離。你可以在擁有測試的情況下重構。

- 你可以替無法控制或很難進行測試的第三方系統進行測試。

- 你可以決定自己設計的彈性與複雜度，而不是被迫使用某些設計模式。

然而，使用不受限框架也有以下缺點：
- 你可能會偽造了不需要的東西，導致失去了在抽象層次較高的角度來了解工作單元。

- 如果不小心，你可能會偽造了不屬於你的 API，可能會導致一些測試無法被維護。但以作者的經驗，情況發生的機會並不頻繁。

### 6.1.3 基於探查器的不受限框架是如何運作的

若你想要撰寫一個.NET不受限框架的競爭產品，這些知識對你會產生額外的幫助。

### 6.1.4 框架揭露了不同的探查器能力

從可能性來說，所有基於探查器的隔離框架，都有同樣的底層功能。但現實中，.NET的主要框架在功能上各有不同。

歷史最為悠久的 **Typemock** 支援所有你在測試遺留程式碼中，沒法測試的東西，包括尚未存在的物件、靜態建構式等。

**Typemock** 只在偽造 **mscorlib.dll** 的 API 方面有所欠缺。包括如 **DateTime**、**System.String** 和 **System.IO** 命名空間的關鍵 API。

技術上， **Typemock** 可允許使用者偽造整個 **mscorlib.dll** ， 但因為效能問題使得這並不可行。

對比 **Typemock Isolator**，**MS Fakes**有一些優勢。由於是微軟內部撰寫，這些開發人員更了解那些沒有在說明文件的探查器 API 。 **MS Fakes** 的 API 主要是允許你用自己的委派來代替公開方法 （靜態或非靜態），但它並不支援對非公開方法的偽實現。

重要的是，要明白在你選擇使用一個隔離框架時，也抉擇了框架所代表的某組基本能力或約束。

---

## 6.2 好的隔離框架的價值

過去.NET領域幾年出現了新的隔離框架，包括了 **Typemock Isolator**、**NSubstitute** 和 **FakeItEasy**。

好的隔離框架具有兩大價值：
- 適應未來
- 可用性

以下是新的測試框架中所支援上述價值的功能：
- 遞迴假物件
- 預設忽略參數
- 大範圍偽造 (Wide faking)
- 假物件的非嚴格行為
- 非嚴格模擬物件

---

## 6.3 支援適應未來和可用性的功能

### 6.3.1 遞迴假物件

### 6.3.2 預設忽略參數

### 6.3.3 大範圍偽造

### 6.3.4 假物件的非嚴格行為

### 6.3.5 非嚴格模擬物件


