# Chapter8. 好的單元測試的支柱

- **可信賴的**：本身沒有bug且測試正確的事。

- **可維護的**：如果修改測試需要花費很多時間，或是經常因很小的程式碼修改就得頻繁調整測試，會使開發人員停止維護。

- **可讀的**：如果無法理解測試意圖，維護工作就會變得困難，也無法得到開發人員的信任。

---

# 8.1 撰寫可信任的測試

如果你在測試出現了非預期的結果後，能夠相信是產品出了問題而不是測試寫錯了，那就是可信任的測試。

**指導原則和技術:**
- 決定何時刪除或修改測試。
- 避免測試中帶著邏輯。
- 一次只測試一個關注點。
- 把單元測試和整合測試分開。
- 推行程式碼審查。

## 8.1.1 決定何時刪除或修改測試

測試寫好了之後通常不應該再去修改或刪除這些測試，但有些情況下這樣做是合理的。

- **產品bug**：被測試的產品程式有bug。
- **測試bug**：測試程式中有bug。
- **語意或API有變更 : 被測試的產品程式碼語意變化，但功能不變。**
- **矛盾或無效的測試**：和測試相關的產品需求異動，產品測試碼跟著改變。

如果測試和產品程式沒有任何問題，你會需要修改和刪除測試的原因可能有：

- 重新命名或重構測試。
- 去除重複的程式碼。


讓我們逐一討論如何處理這些情況：

1. 產品bug：這是理想情況，修改產品程式碼。

2. 測試bug：這種情況，開發人員一般會經歷以下階段。

- **拒絕**：不停地修改產品程式碼。
- **詫異**：呼叫同伴幫忙，一同尋找不存在產品程式碼的bug。
- **偵錯**：慢慢地尋找bug，可能會花上不少時間。
- **接受與頓悟**：恍然大悟，終於發現bug了。

在修復測試bug的過程中，你仍需要確保測試是對的。
（紅燈 -> 綠燈 -> 紅燈）

3. 語意或API變更

```php
public function SemanticsChange()
{
    $logan = new LoginAnalyzer();
    $this->assert->isFalse($logan->IsValid("abc"));
}
```

假設LogAnalyzer語意發生了變化，
呼叫LogAnalyzer的任何方法前都要先呼叫Initialize。

這個測試因為沒有呼叫Initialize所以驗證會拋出例外，
但還是一個有效的測試，只是需要修改測試使用新的語意:

```php
public function SemanticsChange()
{
    $logan = new LoginAnalyzer();
    $logan->Initialize();
    $this->assert->isFalse($logan->IsValid("abc"));
}
```

如果被測試的API不斷變更，修改測試的工作量就會越來越大，以下示範如何調整成一個比較好維護的版本:

```php
public function SemanticsChange()
{
    $logan = $this->makeDefaultAnalyzer();
    $this->assert->isFalse($logan->IsValid("abc"));
}

public function makeDefaultAnalyzer()
{
    $analyzer = new LogAnalyzer();
    $analyzer->Initailize();

    return $analyzer;
}
```

這個重構後的測試使用了一個工廠方法，
使你可以在別的測試中重複使用這個工廠方法，
將來在發生變化時就只要改這個工廠方法。

4. 矛盾或無效的測試 : 和測試相關的產品需求異動，產品程式碼跟著改變。
如果產品加了一個新的功能，和一個測試有直接的矛盾，就產生問題了。

例如:

假設客戶要求LogAnalyzer不支援長度小於4的檔名，
如果檔名小於4，Analyzer應該拋出例外，
程式碼完成了功能，測試也寫好了。

過了一段時間後，客戶發現也需要長度3的檔名，
於是新增了需求，你撰寫了新的測試並且通過了，
但是舊的測試失敗了，這種矛盾的狀況，你需要決定保留哪一個需求。

有時候，矛盾的測試能夠發現客戶需求中的問題，
客戶可能需要決定採用哪個需求。

1. 重新命名或重構測試：詳見8.3。

2. 刪除重複的測試

重複測試的優點：
- 閱讀測試時，可以看得兩種測試的設計方式或語意。

重複測試的缺點：
- 維護同一功能的多個測試比較困難。
- 測試品質參差不齊。
- 一個問題導致多個測試失敗（或許不是壞事）。
- 相似的測試必須用不同的名稱，或分散在不同的類別。

---

## 8.1.2 避免測試中帶著邏輯

隨著測試中的邏輯越來越多，出現bug的機率也會指數上升，
有些測試很簡單，但卻帶有邏輯、亂數產生器或寫檔案的操作，變得越來越複雜。

但是帶有邏輯的測試應該稱作**整合測試**，因為他們對測試的物件只有很少的控制能力，結果的真實性不可被完全信任。

如果單元測試中有包含下面的語句，你的測試就包含了不應該有的邏輯:
- switch、if、else
- foreach、for、while

包含邏輯的測試通常會一次驗證多個東西，這個做法會導致測試變得太過複雜，單元測試應該是一系列的呼叫和驗證。

太過複雜的測試會導致:
- 測試難以閱讀。
- 測試難以重現。
- 測試容易發生bug或測試了錯誤的事情。
- 難以命名測試，因為他執行了多個任務。

下面說明另一個不應該寫在單元測試的邏輯：

```php
public function ProductionLogicProblem()
{
    $user = "user";
    $greeting = "greeting";

    $actual = $this->messageBuilder->build($user, $greeting);
    $this->assert->areEqual($user . $greeting, $actual);
}
```
這段程式碼的問題是，他的期望值是動態定義的，
有可能重複了產品程式碼的邏輯，因此產品程式碼的bug也可能出現在測試中但測試抓不出來。

實際上寫死固定值來撰寫這個程式會更好。

```php
public function ProductionLogicProblem()
{
    $actual = $this->messageBuilder->build("user", "greeting");
    $this->assert->areEqual("user greeting", $actual);
}
```

不只是測試中包含邏輯，測試輔助方法、手刻假物件和測試工具類都可能包含有邏輯，這些都會讓程式碼更難閱讀，也增加了產生bug的可能性。

如果你一定要在測試中包含比較複雜的邏輯，請至少在測試中新增一些測試來幫助你驗證輔助方法的邏輯。

## 8.1.3 每次只測試一個關注點

一個關注點是單元測試的一個最終結果：一個回傳值、系統狀態的改變或對第三方物件的互動。
一次測試多個關注點會讓你難以判斷問題是出在哪裡，並且難以命名測試。

## 8.1.4 把單元測試和整合測試分開


## 8.1.5 用程式碼審查確保程式覆蓋率

一起做程式碼審查可以確保測試品質且覆蓋了所有的程式碼，並且可以互相學習。

> 程式碼審查，是指兩個人坐在一起交談，現場查看和修改同一段程式碼。

**關於程式碼覆蓋率**

可以使用自動化的工具來檢查程式碼的覆蓋狀態，
PHPUnit中有程式碼覆蓋率的報表功能，需安裝XDebug這個PHP套件。

覆蓋率低於20%說明你缺少了很多測試，無法發現錯誤。

以下有一個方法可以檢查你是否新增了一個正確的測試：
1. 註解你認為這個測試所涵蓋的那一段程式碼
2. 執行所有測試
3. 如果測試通過，說明了你還少一個測試或是測試了錯誤的東西
4. 加上缺少的測試並且繼續測試，這個測試預期是會失敗的，以證明你註解掉的程式碼有造成bug
5. 移除註解
6. 再次執行測試，這次應該通過，因為你已經補上了原本缺少的測試
7. 如果測試還是失敗代表還是有bug

總結： 要確保測試在該失敗的時候失敗，你可以刻意加入一個bug來驗證，也可以嘗試把參數或區域變數寫死，檢查結果，增強對測試的信心。



